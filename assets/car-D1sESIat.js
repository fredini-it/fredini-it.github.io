import{M as S,I as D,m as I,a as h,B as b,b as x,g as _,A as N,G as O,D as E,C as F}from"./render-lHAPkZTT.js";async function L(e,r){var u;const{scene:a,animations:o}=e,t=new Set;if(Array.isArray(o)){for(const n of o)if(n!=null&&n.tracks)for(const f of n.tracks){const i=((u=f==null?void 0:f.name)==null?void 0:u.indexOf("."))??-1;i>0&&t.add(f.name.slice(0,i))}}const c=new Map,s=new Map;return a.traverse(n=>{var A,p;if(!n.isMesh&&!n.isInstancedMesh||(y(n),t.has(n.name)||n.parent&&t.has(n.parent.name)))return;const i=n.material,l=i&&i.name?i.name:(i==null?void 0:i.uuid)||"mat",d=n.geometry,w=((p=(A=d==null?void 0:d.attributes)==null?void 0:A.position)==null?void 0:p.count)??0;if(w<500&&G(n)){const m=`${l}_${w}`,M=s.get(m);(M||s.set(m,[]).get(m)).push(n)}else{const m=c.get(l);(m||c.set(l,[]).get(l)).push(n)}}),s.forEach((n,f)=>{if(n.length<=1)return;const i=P(n,f);a.add(i)}),c.forEach((n,f)=>{if(n.length<=1)return;const i=v(n,f);i&&a.add(i)}),a.traverse(n=>{n.isMesh&&!n.material&&(console.error(`Mesh "${n.name}" has no material post-optimization`),n.material=new S({color:16711680}))}),{car:a,animations:o}}function P(e,r){const a=e[0].geometry.clone();C(a);const o=e[0].material,t=new D(a,o,e.length);y(t),t.name=`Instanced_${r}`;for(let c=0;c<e.length;c++){const s=e[c];s.updateMatrixWorld(),t.setMatrixAt(c,s.matrixWorld),s.parent&&s.parent.remove(s)}return t}function v(e,r){const a=new Array(e.length);for(let s=0;s<e.length;s++){const u=e[s],n=u.geometry.clone();C(n),u.updateMatrixWorld(),n.applyMatrix4(u.matrixWorld),a[s]=n}const o=I(a,!1);if(!o)return console.warn(`Failed to merge geometries for material "${r}"`),null;o.attributes.normal||o.computeVertexNormals();const t=e[0].material,c=new h(o,t);y(c),c.name=`Merged_${r}`;for(let s=0;s<e.length;s++){const u=e[s];u.parent&&u.parent.remove(u)}return c}function C(e){const r=e.attributes.position;if(r){if(!e.attributes.normal){const a=new Float32Array(r.count*3);e.setAttribute("normal",new b(a,3))}if(!e.attributes.uv){const a=new Float32Array(r.count*2);e.setAttribute("uv",new b(a,2))}}}function y(e){e.castShadow=!0,e.receiveShadow=!0}function G(e){const r=(e.name||"").toLowerCase();return["badge","bolt","screw","wheel"].some(a=>r.includes(a))}const T="/assets/model/",B="/assets/data/cars.json",$=new Map,g=new E;g.setDecoderPath(F.DRACO_DECODER_PATH);g.preload();async function k(e){const r=await fetch(B);if(!r||!r.ok)throw new Error(`Failed to fetch car data: ${(r==null?void 0:r.status)??"unknown"}`);const a=await r.json(),o=Array.isArray(a)?a.find(t=>(t==null?void 0:t.VIN)===e):null;if(!o)throw new Error(`Car with VIN ${e} not found`);return o}function R(e={}){const r=new Set;for(const a of Object.values(e))if(!(a==null||a==="0"))if(Array.isArray(a))for(const o of a)typeof o=="string"&&o.trim()&&r.add(o.trim());else typeof a=="string"&&a.trim()&&r.add(a.trim());return r.size?Array.from(r):[]}async function V(e,r,a){const o=r||{};e.scene.traverse(t=>{var n,f;if(!t.isMesh&&!t.isInstancedMesh)return;const c=t.material&&t.material.name?t.material.name:t.name,s=o[c];if(s===void 0)return;if(s==="0"){const i=t.parent;if(i&&Array.isArray(i.children)){const l=i.children.find(d=>(d.isMesh||d.isInstancedMesh)&&d!==t&&d.material);l&&l.material&&(t.material=l.material,t.castShadow=!0,t.receiveShadow=!0)}return}if(s===null){t.visible=!1;return}const u=a[s];if(u){t.material=u,t.material.name=s,t.castShadow=((f=(n=t.material)==null?void 0:n.userData)==null?void 0:f.type)!=="glass",t.receiveShadow=!0;return}console.warn(`Material "${s}" not found for "${c}"`),t.material&&(t.material.name=s)})}function j(e,r){const a=new O(e);return a.setDRACOLoader(g),r&&a.setKTX2Loader(r),a}async function W(e,r="ZF01",a,o,t=null){const c=await k(r),s=c.FModel,u=`${T}${s}.glb`,n=R(c.material);let f=$.get(s);if(f)t&&t.updateAssetProgress("sceneInit",`car_${r}`,2,2);else{t&&t.updateAssetProgress("sceneInit",`car_${r}`,0,2);const m=await fetch(u);if(!m||!m.ok)throw new Error(`Failed to fetch ${u}: ${(m==null?void 0:m.status)??"unknown"}`);f=await m.arrayBuffer(),$.set(s,f),t&&t.updateAssetProgress("sceneInit",`car_${r}`,1,2)}x.initialize(a);const i=j(e,o),l=await new Promise((m,M)=>i.parse(f,"",m,M));console.time(`Processing VIN ${r}`);const d=await _(e,a,o,n);await V(l,c.material,d);const{car:w,animations:A}=await L(l);console.timeEnd(`Processing VIN ${r}`);const p=new N(w);return{car:w,mixer:p,animations:A}}export{W as loadCar};
